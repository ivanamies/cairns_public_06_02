#pragma once

#include "rhi/resource_impl.hpp"
#include "rhi/gpu_allocator.hpp"

#include <fastgltf/glm_element_traits.hpp>
#include <fastgltf/core.hpp>
#include <fastgltf/tools.hpp>
#include <fastgltf/util.hpp>

#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>
#include <glm/gtc/type_ptr.hpp>
#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/string_cast.hpp>

#include <memory>

namespace cairns {

// THESE FUNCTIONS WERE mostly GENERATED BY AI.
// "The year is 2026, I'm not writing gltf loading" -- Ivan Amies, Q1 2026
// The AI messed this up btw and cost me ~4 hours of debugging time. It would've been faster if I'd written it myself.

struct VertexAttribute {
    glm::vec4 color = glm::vec4(1.0f);
    glm::vec4 tangent = glm::vec4(0.0f);
    glm::vec4 normal = glm::vec4(0.0f, 0.0f, 1.0f, 0.0f);
    glm::vec2 uv = glm::vec2(0.0f);
    glm::vec2 pad1 = glm::vec2(0.0f);
};

struct Primitive {
    uint32_t firstIndex = 0;
    uint32_t indexCount = 0;
    int32_t  vertexOffset = 0; // Base Vertex (added to index value)
    uint32_t materialIndex = 0;
};

struct Mesh {
    std::string name;
    
    // GPU Handles
    rhi::Handle<rhi::Buffer> posHandle = rhi::Handle<rhi::Buffer>::Null;
    rhi::Handle<rhi::Buffer> attrHandle = rhi::Handle<rhi::Buffer>::Null; // Bindless attributes (UV, Norm, etc)
    rhi::Handle<rhi::Buffer> indexHandle = rhi::Handle<rhi::Buffer>::Null;
    
    // Sub-sections of this mesh
    std::vector<Primitive> primitives;
    
    /////////////////
    // temporaries //
    std::vector<glm::vec4> cpuPositions;
    std::vector<VertexAttribute> cpuAttrs;
    std::vector<uint32_t> cpuIndices;
    /////////////////
};

struct Node {
    std::string name;
    glm::mat4 localTransform = glm::mat4(1.0f);
    glm::mat4 globalTransform = glm::mat4(1.0f);
    
    int32_t meshIndex = -1; // Index into Scene.meshes
    std::vector<int32_t> children;
};

struct Scene {
    
    Scene(Arena& arena) :
    arena_(arena),
    meshes(cairns::Allocator<Mesh>(arena_)),
    nodes(cairns::Allocator<Node>(arena_)),
    rootNodes(cairns::Allocator<int32_t>(arena_)),
    textureHandles(cairns::Allocator<rhi::Handle<rhi::Texture>>(arena_)),
    samplerHandles(cairns::Allocator<rhi::Handle<rhi::Sampler>>(arena_)),
    materialHandles(cairns::Allocator<rhi::Handle<rhi::Material>>(arena_))
    { }
    
    Arena& arena_;
    
    std::vector<Mesh, cairns::Allocator<Mesh>> meshes;
    std::vector<Node, cairns::Allocator<Node>> nodes;
    std::vector<int32_t, cairns::Allocator<int32_t>> rootNodes;
    
    /////////////////
    // temporaries //
    std::vector<rhi::ResourceDescriptor<rhi::Sampler>> loaded_samplers;
    std::vector<rhi::ResourceDescriptor<rhi::Texture>> loaded_textures;
    std::vector<uint32_t> materialToTextureIndex;
    std::vector<uint32_t> materialToSamplerIndex;
    /////////////////
    
    // Bindless Registry Data
    std::vector<rhi::Handle<rhi::Texture>, cairns::Allocator<rhi::Handle<rhi::Texture>>> textureHandles;
    std::vector<rhi::Handle<rhi::Sampler>, cairns::Allocator<rhi::Handle<rhi::Sampler>>> samplerHandles;
    std::vector<rhi::Handle<rhi::Material>, cairns::Allocator<rhi::Handle<rhi::Material>>> materialHandles;

    void CleanupTmps() {
        for ( size_t i = 0; i < loaded_textures.size(); ++i ) {
            auto& tex_desc = loaded_textures[i];
            stbi_image_free(tex_desc.src_image);
        }
        for ( size_t i = 0; i < meshes.size(); ++i ) {
            meshes[i].cpuPositions.clear();
            meshes[i].cpuAttrs.clear();
            meshes[i].cpuIndices.clear();
        }
        loaded_textures.clear();
        loaded_samplers.clear();
        materialToTextureIndex.clear();
        materialToSamplerIndex.clear();
    }
};

inline bool LoadMeshFromGltf(const fastgltf::Asset& asset, const fastgltf::Mesh& gltfMesh, Mesh& outMesh) {
    outMesh.name = std::string(gltfMesh.name);
    outMesh.cpuPositions.clear();
    outMesh.cpuAttrs.clear();
    outMesh.cpuIndices.clear();

    for (const auto& primitive : gltfMesh.primitives) {
        Primitive outPrim;
        outPrim.materialIndex = static_cast<uint32_t>(primitive.materialIndex.value_or(0));
        
        // Offset management: Where this primitive starts in the "Big Buffer"
        outPrim.vertexOffset = static_cast<int32_t>(outMesh.cpuPositions.size());
        outPrim.firstIndex = static_cast<uint32_t>(outMesh.cpuIndices.size());

        size_t vertexCount = 0;

        // 1. POSITIONS
        const auto* posIt = primitive.findAttribute("POSITION");
        if (posIt != primitive.attributes.end()) {
            auto& accessor = asset.accessors[posIt->accessorIndex];
            vertexCount = accessor.count;
            fastgltf::iterateAccessorWithIndex<glm::vec3>(asset, accessor, [&](glm::vec3 v, [[maybe_unused]] size_t i) {
                outMesh.cpuPositions.push_back(glm::vec4(v, 1.0f));
            });
        }
        
        // Resize attributes
        size_t currentAttrOffset = outMesh.cpuAttrs.size();
        outMesh.cpuAttrs.resize(currentAttrOffset + vertexCount);

        // 2. NORMALS
        const auto* normIt = primitive.findAttribute("NORMAL");
        if (normIt != primitive.attributes.end()) {
            auto& accessor = asset.accessors[normIt->accessorIndex];
            fastgltf::iterateAccessorWithIndex<glm::vec3>(asset, accessor, [&](glm::vec3 v, size_t i) {
                outMesh.cpuAttrs[currentAttrOffset + i].normal = glm::vec4(v, 0.0f);
            });
        }

        // 3. UVs
        const auto* uvIt = primitive.findAttribute("TEXCOORD_0");
        if (uvIt != primitive.attributes.end()) {
            auto& accessor = asset.accessors[uvIt->accessorIndex];
            fastgltf::iterateAccessorWithIndex<glm::vec2>(asset, accessor, [&](glm::vec2 v, size_t i) {
                outMesh.cpuAttrs[currentAttrOffset + i].uv = glm::vec2(v.x, v.y);
            });
        }
        
        // 4. COLOR
        const auto* colIt = primitive.findAttribute("COLOR_0");
        if (colIt != primitive.attributes.end()) {
            auto& accessor = asset.accessors[colIt->accessorIndex];
            fastgltf::iterateAccessorWithIndex<glm::vec4>(asset, accessor, [&](glm::vec4 v, size_t i) {
                outMesh.cpuAttrs[currentAttrOffset + i].color = v;
            });
        }

        // 5. INDICES
        if (primitive.indicesAccessor.has_value()) {
            auto& accessor = asset.accessors[*primitive.indicesAccessor];
            outPrim.indexCount = static_cast<uint32_t>(accessor.count);
            fastgltf::iterateAccessorWithIndex<uint32_t>(asset, accessor, [&](uint32_t idx, [[maybe_unused]] size_t i) {
                // Keep indices 0-based relative to the primitive slice
                // Draw command will add `vertexOffset` (baseVertex) to these
                outMesh.cpuIndices.push_back(idx);
            });
        }
        
        outMesh.primitives.push_back(outPrim);
    }
    return true;
}

inline bool LoadSceneFromGltf(const std::filesystem::path& path, Scene& scene) {
    if (!std::filesystem::exists(path)) return false;
    fastgltf::Parser parser;
    auto data = fastgltf::GltfDataBuffer::FromPath(path);
    if (data.error() != fastgltf::Error::None) return false;
    auto assetRes = parser.loadGltfBinary(data.get(), path.parent_path(), fastgltf::Options::None);
    if (assetRes.error() != fastgltf::Error::None) return false;
    const auto& asset = assetRes.get();

    // 1. Textures
    for (const auto& image : asset.images) {
        rhi::ResourceDescriptor<rhi::Texture> texDesc;
        texDesc.undecorated_filename = std::string(image.name);
        const uint8_t* bytes = nullptr; size_t byteLength = 0;
        
        const auto* bufferView = std::get_if<fastgltf::sources::BufferView>(&image.data);
        const auto* byteView = std::get_if<fastgltf::sources::ByteView>(&image.data);
        if (bufferView) {
            auto& view = asset.bufferViews[bufferView->bufferViewIndex];
            auto& buffer = asset.buffers[view.bufferIndex];
            if (auto* vb = std::get_if<fastgltf::sources::Vector>(&buffer.data)) {
                bytes = reinterpret_cast<const uint8_t*>(vb->bytes.data()) + view.byteOffset;
                byteLength = view.byteLength;
            }
            else if (auto* ab = std::get_if<fastgltf::sources::Array>(&buffer.data)) {
                bytes = reinterpret_cast<const uint8_t*>(ab->bytes.data()) + view.byteOffset;
                byteLength = view.byteLength;
            }
        } else if (byteView) {
            bytes = reinterpret_cast<const uint8_t*>(byteView->bytes.data());
            byteLength = byteView->bytes.size();
        }

        if (bytes) {
            int w, h, c;
            unsigned char* raw = stbi_load_from_memory(bytes, (int)byteLength, &w, &h, &c, 4);
            if (raw) {
                if constexpr ( is_vulkan() ) {
                    texDesc.type = static_cast<int64_t>(VK_IMAGE_TYPE_2D);
                    texDesc.storage = static_cast<int64_t>(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
                    texDesc.usage = static_cast<int64_t>(
                        VK_IMAGE_USAGE_SAMPLED_BIT |
                        VK_IMAGE_USAGE_TRANSFER_DST_BIT |
                        VK_IMAGE_USAGE_TRANSFER_SRC_BIT
                    );
                    texDesc.format = static_cast<int64_t>(VK_FORMAT_R8G8B8A8_UNORM);
                }
                else if constexpr ( is_metal() ) {
                    texDesc.type = static_cast<int64_t>(MTL::TextureType2D);
                    texDesc.storage = static_cast<int64_t>(MTL::StorageModeShared);
                    texDesc.usage = static_cast<int64_t>(MTL::TextureUsageShaderRead);
                    texDesc.format = static_cast<int64_t>(MTL::PixelFormatRGBA8Unorm);
                }
                else {
                    assert(false && "must pick one of the two APIs");
                }
                texDesc.sample_count = 1;
                texDesc.width = w;
                texDesc.height = h;
                texDesc.channels = 4;
                texDesc.depth = 1;
                // todo @iamies don't assume all loaded textures must be mip-mapped
                texDesc.levels = static_cast<uint32_t>(std::floor(std::log2(std::max(w, h)))) + 1;
                texDesc.src_bytes_per_row = 4 * w;
                texDesc.src_image = raw;
                scene.loaded_textures.push_back(texDesc);
            }
        }
    }
    
    // 2. Samplers
    // todo @iamies implement mip-mapped samplers
    for (const auto& s : asset.samplers) {
        rhi::ResourceDescriptor<rhi::Sampler> info;
        // todo @iamies remove this mipmap injection hack
        if (s.minFilter || !s.minFilter) {
            fastgltf::Filter f;
            if ( s.minFilter ) {
                f = *s.minFilter;
            }
            else {
                f = fastgltf::Filter::NearestMipMapLinear;
            }
            // Check for Nearest variants
            if (f == fastgltf::Filter::Nearest ||
                f == fastgltf::Filter::NearestMipMapNearest ||
                f == fastgltf::Filter::NearestMipMapLinear) {
                info.minFilter = rhi::SamplerFilter::Nearest;
            } else {
                info.minFilter = rhi::SamplerFilter::Linear;
            }

            // Check for Mipmap variants
            if (f == fastgltf::Filter::NearestMipMapNearest || f == fastgltf::Filter::LinearMipMapNearest) {
                info.mipFilter = rhi::SamplerMipFilter::Nearest;
            } else if (f == fastgltf::Filter::NearestMipMapLinear || f == fastgltf::Filter::LinearMipMapLinear) {
                info.mipFilter = rhi::SamplerMipFilter::Linear;
            } else {
                info.mipFilter = rhi::SamplerMipFilter::None;
            }
        }
        if (s.magFilter) {
            info.magFilter = (*s.magFilter == fastgltf::Filter::Nearest) ?
            rhi::SamplerFilter::Nearest : rhi::SamplerFilter::Linear;
        }
        auto mapWrap = [](fastgltf::Wrap w) {
            if(w==fastgltf::Wrap::ClampToEdge) return rhi::SamplerAddressMode::ClampToEdge;
            if(w==fastgltf::Wrap::MirroredRepeat) return rhi::SamplerAddressMode::MirroredRepeat;
            return rhi::SamplerAddressMode::Repeat;
        };
        info.addressModeU = mapWrap(s.wrapS); info.addressModeV = mapWrap(s.wrapT);
        scene.loaded_samplers.push_back(info);
    }
    
    // 3. Material Mapping
    // ONLY DOES UNLIT MATERIALS
    for (size_t i = 0; i < asset.materials.size(); ++i) {
        const auto& mat = asset.materials[i];
        if (mat.pbrData.baseColorTexture.has_value()) {
            size_t texIdx = mat.pbrData.baseColorTexture->textureIndex;
            int32_t image_index = -1;
            if (texIdx < asset.textures.size() && asset.textures[texIdx].imageIndex.has_value()) {
                image_index = static_cast<uint32_t>(*asset.textures[texIdx].imageIndex);
            }
            int32_t sampler_index = -1;
            if ( texIdx < asset.textures.size() && asset.textures[texIdx].samplerIndex.has_value()) {
                sampler_index = static_cast<uint32_t>(*asset.textures[texIdx].samplerIndex);
            }
            if ( image_index >= 0 && sampler_index >= 0 ) {
                scene.materialToTextureIndex.push_back(image_index);
                scene.materialToSamplerIndex.push_back(sampler_index);
            }
        }
    }

    // 4. Meshes
    for (size_t i = 0; i < asset.meshes.size(); ++i) {
        scene.meshes.push_back(Mesh());
        LoadMeshFromGltf(asset, asset.meshes[i], scene.meshes[i]);
    }
    
    // 5. Nodes
    for (size_t i = 0; i < asset.nodes.size(); ++i) {
        scene.nodes.push_back(Node());
        auto& gn = asset.nodes[i];
        auto& on = scene.nodes[i];
        on.name = std::string(gn.name);
        if (const auto* trs = std::get_if<fastgltf::TRS>(&gn.transform)) {
            glm::vec3 t(trs->translation[0], trs->translation[1], trs->translation[2]);
            glm::quat r(trs->rotation[3], trs->rotation[0], trs->rotation[1], trs->rotation[2]);
            glm::vec3 s(trs->scale[0], trs->scale[1], trs->scale[2]);
            on.localTransform = glm::translate(glm::mat4(1.0f), t) * glm::mat4(r) * glm::scale(glm::mat4(1.0f), s);
        } else if (const auto* mat = std::get_if<fastgltf::math::fmat4x4>(&gn.transform)) {
            on.localTransform = glm::make_mat4(mat->data());
        }
        if (gn.meshIndex.has_value()) on.meshIndex = static_cast<int32_t>(*gn.meshIndex);
        for (auto c : gn.children) on.children.push_back(static_cast<int32_t>(c));
    }
    
    if (!asset.scenes.empty()) {
        for (auto ni : asset.scenes[0].nodeIndices) scene.rootNodes.push_back(static_cast<int32_t>(ni));
    }
    return true;
}

inline void PrepareSceneResources(rhi::Device& device, Scene& scene, rhi::ResourceManager<rhi::Buffer>& buf_mgr, rhi::ResourceManager<rhi::Texture>& tex_mgr, rhi::ResourceManager<rhi::Sampler>& sampler_mgr, rhi::ResourceManager<rhi::Material>& mat_mgr) {
    // Textures
    for (const auto& texDescIn : scene.loaded_textures) {
        rhi::Handle<rhi::Texture> h = tex_mgr.New();
        rhi::ResourceDescriptor<rhi::Texture>* d = tex_mgr.GetDesc(h);
        *d = texDescIn;
        scene.textureHandles.push_back(h);
    }
    
    // Meshes (Consolidated Buffers)
    for (auto& mesh : scene.meshes) {
        mesh.posHandle = buf_mgr.New();
        mesh.attrHandle = buf_mgr.New();
        mesh.indexHandle = buf_mgr.New();
        
        const int64_t align = device.GetGpuAlignUboOffset();
        
        auto* d_pos = buf_mgr.GetDesc(mesh.posHandle);
        d_pos->src_size_bytes = mesh.cpuPositions.size() * sizeof(glm::vec4);
        d_pos->aligned_size_bytes = d_pos->src_size_bytes;
        d_pos->num_vertices = mesh.cpuPositions.size();
        d_pos->usage = rhi::ResourceDescriptor<rhi::Buffer>::Usage::kPosition;
        make_aligned(d_pos->aligned_size_bytes, align);

        auto* d_attr = buf_mgr.GetDesc(mesh.attrHandle);
        d_attr->src_size_bytes = mesh.cpuAttrs.size() * sizeof(VertexAttribute);
        d_attr->aligned_size_bytes = d_attr->src_size_bytes;
        d_attr->num_vertices = mesh.cpuAttrs.size();
        d_attr->usage = rhi::ResourceDescriptor<rhi::Buffer>::Usage::kOtherAttr;
        make_aligned(d_attr->aligned_size_bytes, align);
        
        auto* d_idx = buf_mgr.GetDesc(mesh.indexHandle);
        d_idx->src_size_bytes = mesh.cpuIndices.size() * sizeof(uint32_t);
        d_idx->aligned_size_bytes = d_idx->src_size_bytes;
        d_idx->num_indices = mesh.cpuIndices.size();
        if constexpr ( is_vulkan() ) {
            assert(false && "vulkan todo");
        }
        else if constexpr ( is_metal() ) {
            d_idx->format = static_cast<int64_t>(MTL::IndexTypeUInt32);
        }
        else {
            assert(false);
        }
        d_idx->usage = rhi::ResourceDescriptor<rhi::Buffer>::Usage::kIndex;
        make_aligned(d_idx->aligned_size_bytes, align);
    }
    
    // Samplers
    for (const auto& samplerDesc : scene.loaded_samplers) {
        rhi::Handle<rhi::Sampler> h = sampler_mgr.New();
        rhi::ResourceDescriptor<rhi::Sampler>* d = sampler_mgr.GetDesc(h);
        *d = samplerDesc;
        scene.samplerHandles.push_back(h);
    }
    
    // ONLY DOES UNLIT MATERIALS
    assert(scene.materialToTextureIndex.size() == scene.materialToSamplerIndex.size());
    for ( size_t i = 0; i < scene.materialToTextureIndex.size(); ++i ) {
        uint32_t gltf_tex_idx = scene.materialToTextureIndex[i];
        uint32_t gltf_sampler_idx = scene.materialToSamplerIndex[i];
        auto t = scene.textureHandles[gltf_tex_idx];
        auto s = scene.samplerHandles[gltf_sampler_idx];
        auto m = mat_mgr.New();
        mat_mgr.GetObj(m)->color = t;
        mat_mgr.GetObj(m)->sampler = s;
        scene.materialHandles.push_back(m);
    }
}

} // namespace cairns
